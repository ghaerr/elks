name: nanox

on:
  # Automatic trigger after main completes
  workflow_run:
    workflows: ["main"]
    types:
      - completed

  # Manual trigger (force run)
  workflow_dispatch:

jobs:
  nanox:
    # Only auto-run on success of main; manual runs bypass this
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'workflow_run' &&
       github.event.workflow_run.conclusion == 'success')

    runs-on: ubuntu-22.04

    permissions:
      actions: read
      contents: read

    steps:
      # ------------------------------------------------------------
      # Setup dependencies
      # ------------------------------------------------------------
      - name: setup
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            texinfo \
            libncurses5-dev \
            libelf-dev \
            ncompress \
            git \
            build-essential

      # ------------------------------------------------------------
      # Checkout repo (needed for env.sh, tools, Nano-X build)
      # ------------------------------------------------------------
      - name: checkout
        uses: actions/checkout@v4

      # ------------------------------------------------------------
      # Restore cross toolchain cache
      # ------------------------------------------------------------
      - name: cache
        id: cache
        uses: actions/cache@v4
        with:
          path: cross
          key: cross-${{ hashFiles('tools/*') }}-${{ runner.os }}

      - name: prepare
        if: steps.cache.outputs.cache-hit != 'true'
        run: mkdir -p cross

      - name: build cross toolchain
        if: steps.cache.outputs.cache-hit != 'true'
        run: tools/build.sh

      # ------------------------------------------------------------
      # Download hd32-minix.img from latest successful main run
      # (robust method using gh CLI)
      # ------------------------------------------------------------
      - name: download hd32-minix image via GitHub API
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e

          mkdir -p image

          echo "Finding latest successful 'main' workflow run..."

          RUN_ID=$(gh run list \
            --workflow main \
            --status success \
            --limit 1 \
            --json databaseId \
            -q '.[0].databaseId')

          if [ -z "$RUN_ID" ]; then
            echo "ERROR: No successful 'main' workflow run found"
            exit 1
          fi

          echo "Using main workflow run ID: $RUN_ID"

          echo "Downloading artifact hd32-minix.img..."
          gh run download "$RUN_ID" \
            --name hd32-minix.img \
            --dir image

          echo "Downloaded files:"
          ls -lh image

          test -f image/hd32-minix.img || {
            echo "ERROR: hd32-minix.img not found after download"
            exit 1
          }

      # ------------------------------------------------------------
      # Clone MicroWindows
      # ------------------------------------------------------------
      - name: clone microwindows
        run: |
          git clone https://github.com/ghaerr/microwindows.git

      # ------------------------------------------------------------
      # Build Nano-X for ELKS
      # ------------------------------------------------------------
      - name: build Nano-X for ELKS
        run: |
          cd "$GITHUB_WORKSPACE/elks"
          . ./env.sh
          echo "TOPDIR=$TOPDIR"
          test -d "$TOPDIR/elkscmd"

          cd "$GITHUB_WORKSPACE/microwindows/src"
          make -f Makefile.elks

      # ------------------------------------------------------------
      # Install Nano-X into Minix image
      # ------------------------------------------------------------
      - name: install Nano-X into Minix HDD image
        run: |
          cd "$GITHUB_WORKSPACE/elks"
          . ./env.sh

          IMAGE="$GITHUB_WORKSPACE/image/hd32-minix.img"
          test -f "$IMAGE" || {
            echo "ERROR: hd32-minix.img not found"
            ls -l "$GITHUB_WORKSPACE/image"
            exit 1
          }

          echo "which mfs:"
          which mfs || echo "mfs not found in PATH"

          MFS="$(command -v mfs)"
          echo "Using mfs at: $MFS"

          if [ -z "$MFS" ] || [ ! -x "$MFS" ]; then
            echo "ERROR: mfs not found or not executable"
            exit 1
          fi

          # Ensure directories exist
          "$MFS" "$IMAGE" mkdir /bin || true
          "$MFS" "$IMAGE" mkdir /lib || true

          # Copy Nano-X binaries into /bin
          for f in "$GITHUB_WORKSPACE"/microwindows/src/bin/*; do
            echo "Installing $(basename "$f") into /bin"
            "$MFS" "$IMAGE" cp "$f" /bin
          done

          # Move nxworld.map to /lib
          "$MFS" "$IMAGE" cp "$GITHUB_WORKSPACE/microwindows/src/bin/nxworld.map" /lib
          "$MFS" "$IMAGE" rm /bin/nxworld.map

          echo "Final /bin contents:"
          "$MFS" "$IMAGE" ls /bin

      # ------------------------------------------------------------
      # Upload updated image
      # ------------------------------------------------------------
      - name: upload updated Minix HDD image with Nano-X
        uses: actions/upload-artifact@v4
        with:
          name: hd32-minix-nanox.img
          path: image/hd32-minix.img
